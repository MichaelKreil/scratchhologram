var fs = require('fs');

exports.getRandomPoints = function (count, size) {
	if (!count) count = 30;
	if (!size)  size  = 100;

	var points = [];
	for (var i = 0; i < count; i++) {
		points.push({
			x: size*2*(Math.random()-0.5),
			y: size*2*(Math.random()-0.5),
			z:-size*2*(Math.random()-0.5)
		})
	}

	return Points(points);
}

exports.getJSON = function (filename) {
	var points = fs.readFileSync(filename, 'utf8');
	points = JSON.parse(points);
	points = points.map(function (point) {
		return {
			x: point[0],
			y: point[1],
			z: point[2]
		}
	})

	return Points(points);
}

exports.getMengerSponge = function (depth, s) {
	if (!s) s  = 100;
	var points = [];

	function rec(d, v0) {
		if (d == 0) {
			points.push(v0);
		} else {
			var dn = d-1;
			var vn = vec.scale(v0, 1/3);
			rec(dn, vec.translateXYZ(vn,-s, s,-s));
			rec(dn, vec.translateXYZ(vn, 0, s,-s));
			rec(dn, vec.translateXYZ(vn, s, s,-s));
			rec(dn, vec.translateXYZ(vn, s, 0,-s));
			rec(dn, vec.translateXYZ(vn, s,-s,-s));
			rec(dn, vec.translateXYZ(vn, 0,-s,-s));
			rec(dn, vec.translateXYZ(vn,-s,-s,-s));
			rec(dn, vec.translateXYZ(vn,-s, 0,-s));

			rec(dn, vec.translateXYZ(vn,-s, s, s));
			rec(dn, vec.translateXYZ(vn, 0, s, s));
			rec(dn, vec.translateXYZ(vn, s, s, s));
			rec(dn, vec.translateXYZ(vn, s, 0, s));
			rec(dn, vec.translateXYZ(vn, s,-s, s));
			rec(dn, vec.translateXYZ(vn, 0,-s, s));
			rec(dn, vec.translateXYZ(vn,-s,-s, s));
			rec(dn, vec.translateXYZ(vn,-s, 0, s));

			rec(dn, vec.translateXYZ(vn,-s, s, 0));
			rec(dn, vec.translateXYZ(vn,-s,-s, 0));
			rec(dn, vec.translateXYZ(vn, s,-s, 0));
			rec(dn, vec.translateXYZ(vn, s, s, 0));
		}

	}

	rec(depth, {x:0,y:0,z:0});
	
	return Points(points);
}

exports.getCube = function (count, size) {
	if (!count) count = 10;
	if (!size)  size  = 100;

	var points = {};

	edge([-1,-1,-1],[1,0,0]);
	edge([-1,-1, 1],[1,0,0]);
	edge([-1, 1,-1],[1,0,0]);
	edge([-1, 1, 1],[1,0,0]);

	edge([-1,-1,-1],[0,1,0]);
	edge([-1,-1, 1],[0,1,0]);
	edge([ 1,-1,-1],[0,1,0]);
	edge([ 1,-1, 1],[0,1,0]);

	edge([-1,-1,-1],[0,0,1]);
	edge([-1, 1,-1],[0,0,1]);
	edge([ 1,-1,-1],[0,0,1]);
	edge([ 1, 1,-1],[0,0,1]);

	function edge(p0, pv) {
		for (var i = 0; i <= count; i++) {
			var v = i*2/count;
			var p = [
				Math.round(size*(p0[0] + v*pv[0])*1000)/1000,
				Math.round(size*(p0[1] + v*pv[1])*1000)/1000,
				Math.round(size*(p0[2] + v*pv[2])*1000)/1000
			];
			points[p.join('_')] = p;
		}
	}

	points = Object.keys(points).map(function (key) {
		var p = points[key]
		return {x:p[0], y:p[1], z:p[2]};
	});

	return Points(points);
}

function Points(points) {
	var me = {};
	var data = {
		dots: points.map(function (point) { return { point:point } })
	}

	me.setSun = function (sun) {
		data.sun = sun;
	}

	me.setCam = function (cam) {
		data.cam = cam;
	}



	me.rotateY = function (a) {
		a = a*Math.PI/180;
		data.dots.forEach(function (dot) { dot.point = vec.rotateY(dot.point, a) })
	}
	me.rotateX = function (a) {
		a = a*Math.PI/180;
		data.dots.forEach(function (dot) { dot.point = vec.rotateX(dot.point, a) })
	}
	me.scale = function (s) {
		data.dots.forEach(function (dot) { dot.point.x*=s; dot.point.y*=s; dot.point.z*=s; })
	}
	me.shiftX = function (d) {
		data.dots.forEach(function (dot) { dot.point.x += d; })
	}
	me.shiftY = function (d) {
		data.dots.forEach(function (dot) { dot.point.y += d; })
	}
	me.shiftZ = function (d) {
		data.dots.forEach(function (dot) { dot.point.z += d; })
	}
	me.center = function (d) {
		var minX = 1e10, maxX = -1e10;
		var minY = 1e10, maxY = -1e10;
		var minZ = 1e10, maxZ = -1e10;
		data.dots.forEach(function (dot) {
			var p = dot.point;
			if (minX > p.x) minX = p.x;
			if (minY > p.y) minY = p.y;
			if (minZ > p.z) minZ = p.z;
			if (maxX < p.x) maxX = p.x;
			if (maxY < p.y) maxY = p.y;
			if (maxZ < p.z) maxZ = p.z;
		})
		var dx = -(maxX + minX)/2;
		var dy = -(maxY + minY)/2;
		var dz = -(maxZ + minZ)/2;

		data.dots.forEach(function (dot) {
			dot.point.x += dx;
			dot.point.y += dy;
			dot.point.z += dz;
		})
	}


	me.calcCurves = function () {
		data.dots.forEach(function (dot) { dot.curve = calcCurve(dot.point) });
	}

	function calcCurve (point) {
		var measurements = 25;

		var sun = data.sun;
		var camR = vec.length(data.cam);
		var points = [];
		var py = vec.projectZ(point, vec.setX(data.cam, 0)).y;

		for (var i = -measurements; i <= measurements; i++) {
			var a = i/measurements;
			var cam = vec.setX(data.cam, camR*a);
			var p2D = vec.projectZ(point, cam);
			var px = p2D.x;

			var l1 = sqrt(sqr(sun.x - px) + sqr(sun.y - py) + sqr(sun.z));
			var l2 = sqrt(sqr(cam.x - px) + sqr(cam.y - py) + sqr(cam.z));
			var yd = -((sun.x - px)/l1 + (cam.x - px)/l2) / ((sun.y - py)/l1 + (cam.y - py)/l2);

			points[i+measurements] = {
				x:  p2D.x,
				yd: yd
			}
		}

		points[measurements].y = py;

		for (var j = 1; j <= measurements; j++) {
			var i = measurements + j;
			points[i].y = points[i-1].y + 0.5*(points[i].yd + points[i-1].yd)*(points[i].x - points[i-1].x);
			var i = measurements - j;
			points[i].y = points[i+1].y + 0.5*(points[i].yd + points[i+1].yd)*(points[i].x - points[i+1].x);
		}

		points = points.map(function (p) { return { x:p.x, y:p.y } });

		return points;
	}



	me.getJSON = function () {
		return JSON.stringify(data);
	}

	me.saveJSON = function (filename) {
		fs.writeFileSync(filename, me.getJSON(), 'utf8');
	}

	me.saveJS = function (filename) {
		fs.writeFileSync(filename, 'var data = '+me.getJSON()+';', 'utf8');
	}

	me.getSVG = function () {

		var svg = [];
		data.dots.forEach(function (dot) {
			var curve = dot.curve.map(function (p) {
				return {
					x: 256 + p.x,
					y: 256 - p.y
				}
			})
			svg.push('<path d="'+getSplinePath(curve)+'" fill="none" stroke="#000" stroke-width="0.1" />');
		});

		svg.unshift('<svg version="1.1" baseProfile="basic" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="512px" height="512px" viewBox="0 0 512 512" xml:space="preserve">');
		svg.unshift('<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1 Basic//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-basic.dtd">');
		svg.unshift('<?xml version="1.0" encoding="utf-8"?>');
		svg.push('</svg>');
		return svg.join('\n');
	}

	me.saveSVG = function (filename) {
		fs.writeFileSync(filename, me.getSVG(), 'utf8');
	}

	return me;
}

var vec = {
	length: function (p) {
		return Math.sqrt(p.x*p.x + p.y*p.y + p.z*p.z);
	},

	rotateX: function (p, a) { return { x: p.x, y: p.y*Math.cos(a) - p.z*Math.sin(a), z: p.y*Math.sin(a) + p.z*Math.cos(a) }},
	rotateY: function (p, a) { return { x: p.x*Math.cos(a) - p.z*Math.sin(a), y: p.y, z: p.x*Math.sin(a) + p.z*Math.cos(a) }},
	rotateZ: function (p, a) { return { x: p.y*Math.sin(a) + p.x*Math.cos(a), y: p.y*Math.cos(a) - p.x*Math.sin(a), z: p.z }},

	setX: function (p, v) { return { x:   v, y: p.y, z: p.z } },
	setY: function (p, v) { return { x: p.x, y:   v, z: p.z } },
	setZ: function (p, v) { return { x: p.x, y: p.y, z:   v } },

	scale: function (p, s) { return { x: p.x*s, y: p.y*s, z: p.z*s } },

	translateXYZ: function (p, x, y, z) { return { x: p.x+x, y: p.y+y, z: p.z+z } },


	combine: function (v0, v1, a) {
		return { x: v0.x*(1-a)+a*v1.x, y: v0.y*(1-a)+a*v1.y, z: v0.z*(1-a)+a*v1.z }
	},


	projectZ: function (p, c) {
		var a = (-p.z)/(c.z - p.z);
		return vec.combine(p, c, a);
	}
}

var sqr = function (v) { return v*v };
var sqrt = Math.sqrt;

function getSplinePath(points) {
	function computeControlPoints(K) {
		var p1 = new Array();
		var p2 = new Array();
		var n = K.length - 1;

		var a = [0];
		var b = [2];
		var c = [1];
		var r = [K[0] + 2 * K[1]];

		for (var i = 1; i < n - 1; i++) {
			a[i] = 1;
			b[i] = 4;
			c[i] = 1;
			r[i] = 4 * K[i] + 2 * K[i + 1];
		}

		a[n - 1] = 2;
		b[n - 1] = 7;
		c[n - 1] = 0;
		r[n - 1] = 8 * K[n - 1] + K[n];

		for (var i = 1; i < n; i++) {
			m = a[i] / b[i - 1];
			b[i] = b[i] - m * c[i - 1];
			r[i] = r[i] - m * r[i - 1];
		}

		p1[n - 1] = r[n - 1] / b[n - 1];

		for (var i = n - 2; i >= 0; --i) p1[i] = (r[i] - c[i] * p1[i + 1]) / b[i];

		for (var i = 0; i < n - 1; i++) p2[i] = 2 * K[i + 1] - p1[i + 1];

		p2[n - 1] = 0.5 * (K[n] + p1[n - 1]);

		return {p1: p1, p2: p2};
	}

	var x = [], y = [];

	for (var i = 0; i < points.length; i++) {
		x[i] = points[i].x;
		y[i] = points[i].y;
	}

	px = computeControlPoints(x);
	py = computeControlPoints(y);

	var r = ['M' + x[0] + ',' + y[0]];

	function round(v) {
		return v.toFixed(3);
	}

	for (var i = 0; i < points.length - 1; i++) {
		r.push('C' + round(px.p1[i]) + ',' + round(py.p1[i]) + ',' + round(px.p2[i]) + ',' + round(py.p2[i]) + ',' + round(x[i + 1]) + ',' + round(y[i + 1]));
	}

	return r.join('');
}