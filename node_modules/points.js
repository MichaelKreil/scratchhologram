var fs = require('fs');

exports.getRandomPoints = function (count, size) {
	if (!count) count = 30;
	if (!size)  size  = 100;

	var points = [];
	for (var i = 0; i < count; i++) {
		points.push({
			x: size*2*(Math.random()-0.5),
			y: size*2*(Math.random()-0.5),
			z:-size*2*(Math.random()-0.5)
		})
	}

	return Points(points);
}

exports.getJSON = function (filename) {
	var points = fs.readFileSync(filename, 'utf8');
	points = JSON.parse(points);
	points = points.map(function (point) {
		return {
			x: point[0],
			y: point[1],
			z: point[2]
		}
	})

	return Points(points);
}

exports.getMengerSponge = function (depth, s) {
	if (!s) s  = 100;
	var points = [];

	function rec(d, v0) {
		if (d == 0) {
			points.push(v0);
		} else {
			var dn = d-1;
			var vn = vec.scale(v0, 1/3);
			rec(dn, vec.translateXYZ(vn,-s, s,-s));
			rec(dn, vec.translateXYZ(vn, 0, s,-s));
			rec(dn, vec.translateXYZ(vn, s, s,-s));
			rec(dn, vec.translateXYZ(vn, s, 0,-s));
			rec(dn, vec.translateXYZ(vn, s,-s,-s));
			rec(dn, vec.translateXYZ(vn, 0,-s,-s));
			rec(dn, vec.translateXYZ(vn,-s,-s,-s));
			rec(dn, vec.translateXYZ(vn,-s, 0,-s));

			rec(dn, vec.translateXYZ(vn,-s, s, s));
			rec(dn, vec.translateXYZ(vn, 0, s, s));
			rec(dn, vec.translateXYZ(vn, s, s, s));
			rec(dn, vec.translateXYZ(vn, s, 0, s));
			rec(dn, vec.translateXYZ(vn, s,-s, s));
			rec(dn, vec.translateXYZ(vn, 0,-s, s));
			rec(dn, vec.translateXYZ(vn,-s,-s, s));
			rec(dn, vec.translateXYZ(vn,-s, 0, s));

			rec(dn, vec.translateXYZ(vn,-s, s, 0));
			rec(dn, vec.translateXYZ(vn,-s,-s, 0));
			rec(dn, vec.translateXYZ(vn, s,-s, 0));
			rec(dn, vec.translateXYZ(vn, s, s, 0));
		}

	}

	rec(depth, {x:0,y:0,z:0});
	
	return Points(points);
}

exports.getCube = function (count, size) {
	if (!count) count = 10;
	if (!size)  size  = 100;

	var points = {};

	edge([-1,-1,-1],[1,0,0]);
	edge([-1,-1, 1],[1,0,0]);
	edge([-1, 1,-1],[1,0,0]);
	edge([-1, 1, 1],[1,0,0]);

	edge([-1,-1,-1],[0,1,0]);
	edge([-1,-1, 1],[0,1,0]);
	edge([ 1,-1,-1],[0,1,0]);
	edge([ 1,-1, 1],[0,1,0]);

	edge([-1,-1,-1],[0,0,1]);
	edge([-1, 1,-1],[0,0,1]);
	edge([ 1,-1,-1],[0,0,1]);
	edge([ 1, 1,-1],[0,0,1]);

	function edge(p0, pv) {
		for (var i = 0; i <= count; i++) {
			var v = i*2/count;
			var p = [
				Math.round(size*(p0[0] + v*pv[0])*1000)/1000,
				Math.round(size*(p0[1] + v*pv[1])*1000)/1000,
				Math.round(size*(p0[2] + v*pv[2])*1000)/1000
			];
			points[p.join('_')] = p;
		}
	}

	points = Object.keys(points).map(function (key) {
		var p = points[key]
		return {x:p[0], y:p[1], z:p[2]};
	});

	return Points(points);
}

function Points(points) {
	var me = {};
	var data = {
		dots: points.map(function (point) { return { point:point } })
	}

	me.setSun = function (sun) {
		data.sun = sun;
	}

	me.setCam = function (cam) {
		data.cam = cam;
	}



	me.rotateY = function (a) {
		a = a*Math.PI/180;
		data.dots.forEach(function (dot) { dot.point = vec.rotateY(dot.point, a) })
	}
	me.rotateX = function (a) {
		a = a*Math.PI/180;
		data.dots.forEach(function (dot) { dot.point = vec.rotateX(dot.point, a) })
	}
	me.scale = function (s) {
		data.dots.forEach(function (dot) { dot.point.x*=s; dot.point.y*=s; dot.point.z*=s; })
	}
	me.shiftX = function (d) {
		data.dots.forEach(function (dot) { dot.point.x += d; })
	}
	me.shiftY = function (d) {
		data.dots.forEach(function (dot) { dot.point.y += d; })
	}
	me.shiftZ = function (d) {
		data.dots.forEach(function (dot) { dot.point.z += d; })
	}
	me.center = function (d) {
		var minX = 1e10, maxX = -1e10;
		var minY = 1e10, maxY = -1e10;
		var minZ = 1e10, maxZ = -1e10;
		data.dots.forEach(function (dot) {
			var p = dot.point;
			if (minX > p.x) minX = p.x;
			if (minY > p.y) minY = p.y;
			if (minZ > p.z) minZ = p.z;
			if (maxX < p.x) maxX = p.x;
			if (maxY < p.y) maxY = p.y;
			if (maxZ < p.z) maxZ = p.z;
		})
		var dx = -(maxX + minX)/2;
		var dy = -(maxY + minY)/2;
		var dz = -(maxZ + minZ)/2;

		data.dots.forEach(function (dot) {
			dot.point.x += dx;
			dot.point.y += dy;
			dot.point.z += dz;
		})
	}


	me.calcCurves = function () {
		data.dots.forEach(function (dot) { dot.curve = calcCurve(dot.point) });
	}

	function calcCurve (point) {
		var measurements = 25;

		var sun = data.sun;
		var camR = vec.length(data.cam);
		var points = [];
		var py = vec.projectZ(point, vec.setX(data.cam, 0)).y;

		for (var i = -measurements; i <= measurements; i++) {
			var a = i/measurements;
			var cam = vec.setX(data.cam, camR*a);
			var p2D = vec.projectZ(point, cam);
			var px = p2D.x;

			var l1 = sqrt(sqr(sun.x - px) + sqr(sun.y - py) + sqr(sun.z));
			var l2 = sqrt(sqr(cam.x - px) + sqr(cam.y - py) + sqr(cam.z));
			var yd = -((sun.x - px)/l1 + (cam.x - px)/l2) / ((sun.y - py)/l1 + (cam.y - py)/l2);

			points[i+measurements] = {
				x:  p2D.x,
				yd: yd
			}
		}

		points[measurements].y = py;

		for (var j = 1; j <= measurements; j++) {
			var i = measurements + j;
			points[i].y = points[i-1].y + 0.5*(points[i].yd + points[i-1].yd)*(points[i].x - points[i-1].x);
			var i = measurements - j;
			points[i].y = points[i+1].y + 0.5*(points[i].yd + points[i+1].yd)*(points[i].x - points[i+1].x);
		}

		points = points.map(function (p) { return { x:p.x, y:p.y } });

		return points;
	}



	me.getJSON = function () {
		return JSON.stringify(data);
	}

	me.saveJSON = function (filename) {
		fs.writeFileSync(filename, me.getJSON(), 'utf8');
	}

	me.saveJS = function (filename) {
		fs.writeFileSync(filename, 'var data = '+me.getJSON()+';', 'utf8');
	}

	return me;
}

var vec = {
	length: function (p) {
		return Math.sqrt(p.x*p.x + p.y*p.y + p.z*p.z);
	},

	rotateX: function (p, a) { return { x: p.x, y: p.y*Math.cos(a) - p.z*Math.sin(a), z: p.y*Math.sin(a) + p.z*Math.cos(a) }},
	rotateY: function (p, a) { return { x: p.x*Math.cos(a) - p.z*Math.sin(a), y: p.y, z: p.x*Math.sin(a) + p.z*Math.cos(a) }},
	rotateZ: function (p, a) { return { x: p.y*Math.sin(a) + p.x*Math.cos(a), y: p.y*Math.cos(a) - p.x*Math.sin(a), z: p.z }},

	setX: function (p, v) { return { x:   v, y: p.y, z: p.z } },
	setY: function (p, v) { return { x: p.x, y:   v, z: p.z } },
	setZ: function (p, v) { return { x: p.x, y: p.y, z:   v } },

	scale: function (p, s) { return { x: p.x*s, y: p.y*s, z: p.z*s } },

	translateXYZ: function (p, x, y, z) { return { x: p.x+x, y: p.y+y, z: p.z+z } },


	combine: function (v0, v1, a) {
		return { x: v0.x*(1-a)+a*v1.x, y: v0.y*(1-a)+a*v1.y, z: v0.z*(1-a)+a*v1.z }
	},


	projectZ: function (p, c) {
		var a = (-p.z)/(c.z - p.z);
		return vec.combine(p, c, a);
	}
}

var sqr = function (v) { return v*v };
var sqrt = Math.sqrt;